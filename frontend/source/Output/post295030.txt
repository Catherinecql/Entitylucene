How to write an AppleScript that downloads Wi-Fi network status from router's web interface? <body> h2strongObjectives:/strong/h2  I want to create an AppleScript .scpt file that does the following:  ol liAccesses a router's webpage (i.e., its IP address)./li liFrom this webpage, gets the IP addresses that are currently connected to both networks. (By "both networks", I refer to the separate 2.4Ghz and 5.0Ghz wireless networks.)/li liFrom the webpage, gets the respective Dbm signal strengths of each connected device (i.e., each connected IP address)./li /ol  hr  h2strongImplementation:/strong/h2  I want one AppleScript codelist/code object to contain all of the IP addresses:   ul liE.g.: codetheListOfIPs/code contains code{"192.168.0.1", "192.168.0.", "192.168.0.3", "192.168.0.4", "192.168.0.5", "192.168.0.6.", "192.168.0.7"}/code./li /ul  (I do not have the need to differentiate between the IPs that are connected to the 2.4GHz network and the IPs that are connected to the 5.0GHz network. All IPs should simply be contained in codetheListOfIPs/code.)  And, one AppleScript codelist/code object to contain their corresponding signal strengths:  ul liE.g.: codetheListOfTheirSignalStrengths/code contains code{"0", "-75", "-40", "0", "0", "-63", "-72"}/code./li /ul  hr  h2strongNotes:/strong/h2  ul liI would like all of this to be completed "behind the scenes." Unobtrusiveness is really key, because the script will need to periodically check the router's website for network updates./li liUltimately, changes to the network status will be written to a .txt log file, and an alert notification will be displayed, when certain conditions are met. I know how to code these components; I need help actually importing the data into the script./li liBrowser of choice: Google Chrome/li /ul  hr  h2strongBackground:/strong/h2  I have used the shell command , codecurl/code, before, in order to import the unabridged HTML source code of a given website into an AppleScript, as a codetext/code object. I understand that, sadly, one cannot similarly or conveniently get all JavaScript elements into an AppleScript as a single text object.  Instead, one must get each and every JavaScript element individually, by some identifier, like its codeid/code, codeclass/code, codetag/code, or codename/code. This makes things more complicated (because you can't simply parse everything in AppleScript).  By using Chrome's kbdInspect/kbd feature, and the kbdElements/kbd pane of Chrome's JavaScript console, I've determined the relevant JavaScript identifiers. The two JavaScript element IDs that contain all IP addresses, as well as their signal strengths, are codewifi-24/code and codewifi-5/code.  Can someone teach me how to write the necessary JavaScript code correctly, and then parse the resulting HTML text, to isolate the basic network data that I desire?  hr  <answer295038> ol liGo to the web page in the Chrome browser./li liOpen the Dev Tools' JavaScript browser./li liStick this in the console and hit enter:/li /ol  &nbsp;  precode$('script').each(function(){     console.log($(this).html()) }); /code/pre  <answer295134> Based on the discussions had, this should handle the original scope of the question.  Note: This is example emcode/em and does not contain much, if any, error handling. I'll leave that to you since this is only a portion of the overall script, once you put all the other pieces together.  precode--  #  --  #   Get the target information from theTargetURL in Google Chrome. --  #    --  #   Do this in the background, so get the 'tab id' and 'window id' of --  #   the target URL ('theTargetURL') if it exists, and process accordingly.   set theTargetURL to "http://192.168.1.1/0.1/gui/#/"  tell application "Google Chrome"     if running then         set theWindowList to every window         repeat with thisWindow in theWindowList             set theTabList to every tab of thisWindow             repeat with thisTab in theTabList                 if theTargetURL is equal to (URL of thisTab as string) then                      --  #   Get the targeted content of the web page which contains the information.                     --  #   Note that document.getElementById(elementID) can only query one                     --  #   element at a time, therefore call it twice, once with each elementID.                      set rawWiFi24HTML to thisTab execute javascript "document.getElementById('wifi-24').innerHTML;"                     set rawWiFi5HTML to thisTab execute javascript "document.getElementById('wifi-5').innerHTML;"                      tell current application                          --  #   Process the 'rawWiFi24HTML' and 'rawWiFi5HTML' variables.                         --  #   Setup some temporary files to handle the processing.                          set rawHTML to "/tmp/rawHTML.tmp"                         set rawIP to "/tmp/rawIP.tmp"                         set rawDBM to "/tmp/rawDBM.tmp"                          --  #   Combine the value of  the'rawWiFi24HTML' and 'rawWiFi5HTML' variables into the 'rawHTML' temporary file.                          do shell script "echo " &amp; quoted form of rawWiFi24HTML &amp; " &gt; " &amp; rawHTML &amp; "; echo " &amp; quoted form of rawWiFi5HTML &amp; " &gt;&gt; " &amp; rawHTML                          --  # Process the 'rawHTML' into the 'rawIP' and 'rawDBM' temporary files.                         --  # These files will contain comma delimited content of the targeted info.                          do shell script "grep 'IP:' " &amp; rawHTML &amp; " | sed -e 's:&lt;/span&gt;.*$::g' -e 's:^.*&gt;::g' | tr '\\12' ',' &gt; " &amp; rawIP &amp; "; grep 'device.parsedSignalStrength' " &amp; rawHTML &amp; " | sed -e 's: dBM.*$::g' -e 's:^.*\"::g' | tr '\\12' ',' &gt; " &amp; rawDBM                          -- Process 'rawIP' and 'rawDBM' temporary files into 'theIPAddressList' and 'theSignalStrengthList' lists.                          set theIPAddressList to my makeListFromCSVFile(rawIP)                         set theSignalStrengthList to my makeListFromCSVFile(rawDBM)                          --  #   Clean up, remove temporary files.                          do shell script "rm /tmp/raw*.tmp"                      end tell                  end if             end repeat         end repeat     end if end tell  --  # Handler used to create a list from a CSV file.  on makeListFromCSVFile(thisFile)     set thisFilesContents to (read thisFile)     set AppleScript's text item delimiters to {","}     set thisList to items 1 thru -2 of text items of thisFilesContents as list     set AppleScript's text item delimiters to {}     return thisList end makeListFromCSVFile     --  ######################################### --  #    --  #   Checking the output of the code: --  #    --  #   The following commands are here just to show the contents --  #   of the two lists displayed in a default list box, and then a way  --  #   both lists might be combined, the output of which is logged. --  #    --  #   This of course can be removed after testing is finished. --  #    tell current application     --  #     choose from list theIPAddressList &amp; theSignalStrengthList     --  #     repeat with i from 1 to (count of theIPAddressList)         log "IP: " &amp; item i of theIPAddressList &amp; " @ " &amp; item i of theSignalStrengthList &amp; " Dbm"     end repeat     --  # end tell --  #    --  ######################################### /code/pre  I do have to say that generally speaking, one is not supposed to parse HTML with tools like codegrep/code and codesed/code, however, for certain pages, like in this use case, it's pretty safe to do. Although, if it breaks, it's not hard to fix.  <comment372361> The problem is that the desired URL is behind a username/password page. If I pasted the URL here, it would be meaningless to you. <comment372370> Okay. I wasn't asking for a customized solution. I just want to know if this is even possible, and, if it is, a general idea of how to approach it. Here is a more direct version of my question: Is it possible to scrape *all* of the JavaScript elements from a website? Your comment leads me to believe that the answer to this question varies significantly from site to site, but I do not understand why the answer would vary. Isn't this a yes/no question? <comment372371> Your question is all over the place. Yes it is possible. Without an actual example of a site you are interested in .js scraping, there is no one applescript fits all approach. <comment372372> @Mr.Kennedy Can you point me in the right direction, so I can start learning about this? What is the relevant command to accomplish this? I don't know where to begin. <comment372373> To scrape all the javascript, you'll need to learn how html and javascript work together. View the source HTML - look for the `*.js` files. Dynamic pages will present more issues. Start with a simple and small example of html/JS and build your AppleScript. Then figure out more complex HTML/JS situations and develop your tool to accommodate them. <comment372374> as an example, view the source of this web page. search for `javascript` and `.js` try and figure out what all is going on in the script. If you are new to HTML... well, it's not painting by numbers. <comment372375> I followed these instructions. What should I be looking for or what's the next step? Thank you. <comment372383> @Mr.Kennedy The URL is the IP of a wireless router. Okay, from the HTML source code, I was able to find the relevant `.js` file. [Here](https://paste.ee/p/Rl4CZ) is the HTML source code. [Here](https://paste.ee/p/VTRsZ) is the full text of the relevant `.js` file. The data that I ultimately want to import into my AppleScript is each `device.ipAddress` and its corresponding `wifiStrength` figure (or, alternatively, its corresponding `device.signalStrength` figure). <comment372387> I copied the relevant code found in Chrome's JavaScript Element window, and pasted this text into TextEdit, so that I could color the text to better demonstrate what I want: [Here](http://i.imgur.com/mXmibud.png) is a screenshot. The text in blue is the data that I want to import into my AppleScript; I ultimately need two, corresponding lists in my AppleScript. In this screenshot's case, `theListOfIPs` would contain `{"192.168.1.9", "192.168.1.10"}` and `theListOfTheirSignalStrengths` would contain `{"0", "-75"}`. (In reality, each list will contain more than two items.) <comment372390> Let us [continue this discussion in chat](http://chat.stackexchange.com/rooms/63736/discussion-between-mr-kennedy-and-rubiks-sphere). <comment372398> You could've at least made it log instead of alerting, that's just painful. <comment372504> @Sirens there you go. My main point was to demonstrate that the OP was headed in the wrong direction. Per the chat room conversation, they've found a better way. <comment372582> When I incorporated your code into my larger script, I was getting the error: `Canâ€™t make current application into type file.`. I realized that the following line in my script was responsible for the error: `use framework "Foundation"`. After I changed your line `(read POSIX file thisFile)` to `(read POSIX path of thisFile)` or simply to `(read thisFile)`, your code now functions properly within my script, without error. <comment372584> Yes, this is why I said "Note: This is example _code_ ...", because if you take the _code_ as is and copy it into a new document in Script Editor as the only code in the script, it works, but when one starts integrating _code_ from other sources there is bound to be issues that need to be addressed. <comment372591> Is it just me, or are the final list objects nested versions of themselves? That is, if you `return theIPAddressList` or if you `return theSignalStrengthList`, you will see that `item x` of either list (where `x` is any item of the list), is actually the desired list itself. This peculiarity will be masked if you use `choose from list`, but you can see the true list contents if you use `return`. [Here are screenshots](http://i.imgur.com/f6Ifv48.jpg). <comment372611> @user3439894 No worries, I'll revise the question so its clearer when we are all said and done. When you get the chance, can you take a look at [my error handling attempt](https://paste.ee/p/IDXyo) for your code, and improve it as you see fit? Thank you. <comment372680> @rubik's sphere, I have changed the code to create comma delimited temporary files and the way in which the contents of those files are turned into the wanted lists. <comment373098> Very nice edit/rewrite of the question. If I could +1 again, I would! :) I'll try to get the update added to my answer tomorrow that will cover what's happening in the `do shell script` _commands_ and parsing the HTML. <comment373101> You wrote, *"Generally speaking, one is not supposed to parse HTML with tools like grep and sed."* Could you explain why this is, exactly? What is the alternative for parsing HTML text? <comment373102> @rubik's sphere, I will in the update that I'll do.